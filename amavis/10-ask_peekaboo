###############################################################################
#                                                                             #
# Peekaboo Extended Email Attachment Behavior Observation Owl                 #
#                                                                             #
# 10-ask_peekaboo
###############################################################################
#                                                                             #
# Copyright (C) 2016-2020  science + computing ag                             #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or (at       #
# your option) any later version.                                             #
#                                                                             #
# This program is distributed in the hope that it will be useful, but         #
# WITHOUT ANY WARRANTY; without even the implied warranty of                  #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           #
# General Public License for more details.                                    #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

use strict;

# define our own JSON-based protocol by plugging into AMaViS' AV control flow.
# Standard ask_daemon call graph:
#
# virus_scan (iterate over active virus scanners)
# -> ask_daemon (decide what protocol routine to use)
# -> run_av (iterate over files, run scanner and collect results)
# -> ask_daemon_internal (protocol routine: communicate with scanner)
#
# Our call graph:
#
# virus_scan
# -> ask_peekaboo (force our protocol routine)
# -> run_av
# -> ask_peekaboo_internal (override query to JSON)
# -> ask_daemon_internal
#
# See below for reasoning.

# use pure-perl implementation since performance should be enough for our needs
# and it's been a core module since 5.14, avoiding an additional dependency on
# JSON or JSON::XS
use JSON::PP;
# Yes, Amavis has its own minimalist JSON implementation Amavis::JSON. But it
# doesn't seem to do UTF-8 encoding correctly - everything ends up as latin1.
use LWP::UserAgent;
use File::Basename;
use Data::Dumper;

# monkey patch a content_disposition setter/getter into the Parts package
*{Amavis::Unpackers::Part::content_disposition} = sub {
  @_<2 ? shift->{co_disp} : ($_[0]->{co_disp} = $_[1]);
};

# monkey patch a wrapper for mime_traverse into the MIME package
my $amavis_mime_traverse = \&Amavis::Unpackers::MIME::mime_traverse;
*{Amavis::Unpackers::MIME::mime_traverse} = sub ($$$$$) {
  my($entity, $tempdir, $parent_obj, $depth, $placement) = @_;

  &$amavis_mime_traverse($entity, $tempdir, $parent_obj, $depth, $placement);

  # go through list of children detected by call above and assign additional
  # properties
  foreach my $child (@{$parent_obj->children}) {
    $child->content_disposition($entity->head->mime_attr('content-disposition'));
  }
};

sub ask_peekaboo_internal {
  my ($url, $dummy, $names_to_parts, $dummy) = @_;
  my ( $rateNames, $rateValues );

  %$rateValues = ( "unchecked" => 1, "unknown" => 2, "ignored" => 3, "good" => 4, "failed" => 5, "bad" => 6 );
  %$rateNames = reverse %$rateValues;

  # extract some additional info for peekaboo from the parts objects
  # structure:
  # [ { "full_name" => "<path>", "name_declared" => ..., ... },
  #   { ... },
  #   ... ]
  my $metainfo = [];
  foreach my $partname (keys %{$names_to_parts}) {
    my $pmi = {};

    my $part = $names_to_parts->{$partname};
    for my $field (qw( full_name name_declared type_declared content_disposition )) {
      my $val = $part->$field();

      # name_declared can be an array of names, if so use the last
      $val = ref $val eq 'ARRAY' ? $val->[-1] : $val;

      # when running under perl 5.22.1 e.g. on Ubuntu 16.04 safe_decode_mime
      # somehow corrupts the original value of $val so we may get errors in
      # totally unrelated code later on such as:
      #   FAILED: Malformed UTF-8 character (fatal) at /usr/sbin/amavisd-new
      #   line 10210.
      # We work around that by forcing a copy.
      $val = Amavis::Util::safe_decode_mime("" . $val) if $field eq "name_declared";

      # do not transfer undef values since they're no good for nothing
      $pmi->{$field} = $val if defined($val);
    }

    # add more elements to the part hash, will be used when talking with peekaboo
    $pmi->{"status"} = undef;   # HTTP return code
    $pmi->{"rating"} = undef;   # Peekaboo rating
    $pmi->{"content"} = undef;  # Text messages from peekaboo
    $pmi->{"job_id"} = undef;   # Checksum for this part
    push(@$metainfo, $pmi);
  }

  # prepare and run http reuqests to the peekaboo server and receive (wait) for the results
  my $ua = LWP::UserAgent->new();
  # note: we receive the url from @av_scanners ( 15-av_scanners )
  my $scanUrl = "${url}/v1/scan";
  my $reportUrlTmpl = "${url}/v1/report/JOB_ID";

  my $workDone = 0; # loop control variable, will be set to true if all results are present
  while ( ! $workDone ) {
    # loop over the parts
    foreach my $part ( @$metainfo ) {
      # note: we get a dict/hash as loop var

      # check if the part was created a a file
      next if ! defined ( $part->{"full_name"} ) || ! -e $part->{"full_name"};

      # check if this is the first call
      if ( ! defined( $part->{"status"} ) || ! $part->{"status"} ) {

        # first call: run POST scanfile
        my $answer = $ua->post($scanUrl,
          Content_Type => 'form-data',
          # could be per-file but complicates handling server-side
          'X-Content-Disposition' => $part->{"content_disposition"},
          Content => [
            'file' => [
              $part->{"full_name"},
              $part->{"name_declared"} || undef,
              Content_Type => $part->{"type_declared"},
            ]
          ]
        );

        if ( $answer->{"_rc"} eq "200" ) {
          # decode the text part of the response
          my $tokens = JSON::PP->new->utf8->decode($answer->{"_content"});
          # Amavis::Util::do_log( 1, "Examine tokens: '%s'", Dumper $tokens );
          $part->{"job_id"} = $tokens->{"job_id"}; # extract the checksum
          $part->{"status"} = $answer->{"_rc"};
          Amavis::Util::do_log( 2, "Post: Found 200 for %s: %s", basename( $part->{"full_name"} ), $part->{"job_id"});

        } else {
          # seems we have got an error... log it
          Amavis::Util::do_log( 1, "Post: Do not know how to handle state '%s'", $answer->{"_rc"} );
          die sprintf( "Receive unexpected state %s", $answer->{"_rc"} );
        }
      } elsif ( defined( $part->{"status"} ) && $part->{"status"} eq "200" ) {

        # the part has already been requested, now we try to get a report
        Amavis::Util::do_log( 3, "Found state %s: ask with '%s'", $part->{"status"}, $part->{"job_id"});
        my $url = $reportUrlTmpl;
        $url =~ s/JOB_ID/$part->{"job_id"}/;
        Amavis::Util::do_log( 3, "Resulting url: '$url'");

        my $answer = $ua->get($url);
        Amavis::Util::do_log( 1, "Found answer as '%s'", $answer->{"_rc"} );

        if ( $answer->{"_rc"} eq "200" ) {
          $part->{"status"} = $answer->{"_rc"};
          $part->{"content"} = ( JSON::PP->new->utf8->decode($answer->{"_content"})->{"report"} );
          $part->{"rating"} = ( JSON::PP->new->utf8->decode($answer->{"_content"})->{"result"} );
        } elsif ( $answer->{"_rc"} eq "202" ) {
          # result still not present
          Amavis::Util::do_log( 3, "Answer still not present '%s'", $answer->{"_rc"} );
        } else {
          # seems we have got an error... log it
          Amavis::Util::do_log( 1, "Post: Do not know how to handle state '%s'", $answer->{"_rc"} );
          die sprintf( "Receive unexpected state %s", $answer->{"_rc"} );
        }
      } else {
        # seems we have got an error... log it
        Amavis::Util::do_log( 1, "Post: Do not know how to handle state '%s'", $part->{"status"} );
        die sprintf( "Receive unexpected state %s", $part->{"status"} );
      }
    }
    my $stateList = [];
    # check if we need another loop pass
    foreach my $part ( @$metainfo ) {
      push @$stateList, $part->{"status"} if defined( $part->{"status"} ) && $part->{"status"} eq "200";
    }
    # if all state are 200 we are done
    if ( $#$stateList eq $#$metainfo ) {
      $workDone = 1;
    }
    # now we need to sleep a little
    sleep(0.1) if ! $workDone;
  }
  # build the result text
  my $resultText = "";
  my $totalRate = -1;
  foreach my $part ( @$metainfo ) {
    foreach my $line ( @{ $part->{"content"} } ) {
      $resultText .= $line . "\n";
    }
    $resultText .= "\n";
    $totalRate = $part->{ "rating" } if $part->{ "rating" } > $totalRate;
  }
  # add the grep pattern
  $resultText .= sprintf("PeekabooResult:%s", $rateNames->{ $totalRate } );
  # compute return value (rate good = False, all other are True)
  my $ret = $totalRate == 4 ? 0 : 1;

  # Amavis::AV::ask_daemon_internal(@_);
  # Can't use string ("{"result":["Datei \\"blank.doc\\" "...) as a HASH ref while
  # $res = Dumper $req->{"_content"};
  #
  # Returns a triplet, or dies in case of failure.
  # The first element of the triplet has the following semantics:
  # - true if virus found,
  # - 0 if no viruses found,
  # - undef if it did not complete its job;
  # the second element is a string, the text as provided by the virus scanner;
  # the third element is ref to a list of virus names found (if any).
  #   (it is guaranteed the list will be nonempty if virus was found)

  return ( $ret, $resultText );
}

# force run_av to execute our protocol routine so we can generate the final
# JSON request structure there. We cannot do it here because run_av will expand
# special placeholders {} and * in the query template and corrupt our JSON if
# it contains those, either because of empty hashes formatted as {} or just a
# simple file name containing the sequence.
sub ask_peekaboo {
  my (@run_av_args) = @_;

  # be sure to patch a copy and not @_ because this would change the referenced
  # call parameter and make the next call to us go directly to _internal
  # instead, resulting in error messages like: Peekaboo-Analysis av-scanner
  # FAILED: Can't use string ("/var/lib/amavis/tmp/amavis-20180"...) as a HASH
  # ref while "strict refs" in use at /etc/amavis/conf.d/10-ask_peekaboo line
  # 61.
  $run_av_args[4] = \&ask_peekaboo_internal;
  Amavis::AV::run_av(@run_av_args);
}

1;  # ensure a defined return value
