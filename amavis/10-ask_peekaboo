###############################################################################
#                                                                             #
# Peekaboo Extended Email Attachment Behavior Observation Owl                 #
#                                                                             #
# 10-ask_peekaboo
###############################################################################
#                                                                             #
# Copyright (C) 2016-2020  science + computing ag                             #
#                                                                             #
# This program is free software: you can redistribute it and/or modify        #
# it under the terms of the GNU General Public License as published by        #
# the Free Software Foundation, either version 3 of the License, or (at       #
# your option) any later version.                                             #
#                                                                             #
# This program is distributed in the hope that it will be useful, but         #
# WITHOUT ANY WARRANTY; without even the implied warranty of                  #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU           #
# General Public License for more details.                                    #
#                                                                             #
# You should have received a copy of the GNU General Public License           #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.       #
#                                                                             #
###############################################################################

use strict;

# use pure-perl implementation since performance should be enough for our needs
# and it's been a core module since 5.14, avoiding an additional dependency on
# JSON or JSON::XS
use JSON::PP;
# Yes, Amavis has its own minimalist JSON implementation Amavis::JSON. But it
# doesn't seem to do UTF-8 encoding correctly - everything ends up as latin1.

use LWP::UserAgent;

# monkey patch a content_disposition setter/getter into the Parts package
*{Amavis::Unpackers::Part::content_disposition} = sub {
  @_<2 ? shift->{co_disp} : ($_[0]->{co_disp} = $_[1]);
};

# monkey patch a wrapper for mime_traverse into the MIME package
my $amavis_mime_traverse = \&Amavis::Unpackers::MIME::mime_traverse;
*{Amavis::Unpackers::MIME::mime_traverse} = sub ($$$$$) {
  my($entity, $tempdir, $parent_obj, $depth, $placement) = @_;

  &$amavis_mime_traverse($entity, $tempdir, $parent_obj, $depth, $placement);

  # go through list of children detected by call above and assign additional
  # properties
  foreach my $child (@{$parent_obj->children}) {
    $child->content_disposition($entity->head->mime_attr('content-disposition'));
  }
};

sub ask_peekaboo {
  my($dummy, $names_to_parts, $dummy, $av_name, $dummy, $args, $dummy,
     $dummy, $dummy) = @_;

  # we receive the url and potentially other parameters from @av_scanners (15-av_scanners)
  my $base_url = "http://127.0.0.1:8100";
  my $polling_interval = 5;

  if (defined($args)) {
    $base_url = $$args[0] if (defined($$args[0]));
    $polling_interval = $$args[1] if (defined($$args[1]));
  }

  my $scan_url = "${base_url}/v1/scan";
  my $report_url_tmpl = "${base_url}/v1/report/%d";

  # extract some additional info for peekaboo from the parts objects and
  # prepare and run http reuqests to the peekaboo server
  my $ua = LWP::UserAgent->new();
  my @jobs;
  my $result_text = "";
  foreach my $partname (keys %{$names_to_parts}) {
    my $pmi = {};

    my $part = $names_to_parts->{$partname};
    for my $field (qw( full_name name_declared type_declared content_disposition )) {
      my $val = $part->$field();

      # name_declared can be an array of names, if so use the last
      $val = ref $val eq 'ARRAY' ? $val->[-1] : $val;

      # when running under perl 5.22.1 e.g. on Ubuntu 16.04 safe_decode_mime
      # somehow corrupts the original value of $val so we may get errors in
      # totally unrelated code later on such as:
      #   FAILED: Malformed UTF-8 character (fatal) at /usr/sbin/amavisd-new
      #   line 10210.
      # We work around that by forcing a copy.
      $val = Amavis::Util::safe_decode_mime("" . $val) if $field eq "name_declared";

      # do not transfer undef values since they're no good for nothing
      $pmi->{$field} = $val if defined($val);
    }

    my $answer = $ua->post($scan_url,
      Content_Type => 'form-data',
      # could be per-file but complicates handling server-side
      'X-Content-Disposition' => $pmi->{"content_disposition"},
      Content => [
        'file' => [
          $pmi->{"full_name"},
          $pmi->{"name_declared"} || undef,
          Content_Type => $pmi->{"type_declared"},
        ]
      ]
    );

    my $code = $answer->code;
    if ($code != 200) {
      my $message = sprintf("Peekaboo: Received error %d when submitting %s",
              $code, $partname);
      Amavis::Util::do_log(1, $message);
      return (undef, $result_text . $message . "\n", undef);
    }

    # decode the text part of the response
    my $peekaboo_response = JSON::PP->new->utf8->decode(
            $answer->decoded_content);
    my $job = $peekaboo_response->{"job_id"};

    my $message = sprintf("Peekaboo: %s submitted as job %d", $partname, $job);
    Amavis::Util::do_log(5, "Peekaboo: " . $message);
    $result_text .= $message . "\n";

    push(@jobs, $job);
  }

  # poll the running jobs until all are done
  my @jobs_left = ();
  while (@jobs) {
    my $duration = $polling_interval;
    my $numjobs = $#jobs + 1;
    if (!@jobs_left) {
      # sleep a hundredth of the polling interval per job on the first loop in
      # case all jobs got answered from cached results and are ready very
      # quickly
      $duration = $polling_interval / 100 * $#jobs;
    }

    Amavis::Util::do_log(5, "Peekaboo: Sleeping %.2f seconds before " .
            "polling %d jobs again", $duration, $numjobs);
    sleep($duration);

    @jobs_left = ();
    for my $job (@jobs) {
      my $answer = $ua->get(sprintf($report_url_tmpl, $job));

      my $code = $answer->code;
      if ($code == 200) {
        my $message = sprintf("Peekaboo: Received report for job %d", $job);
        Amavis::Util::do_log(5, $message);
        $result_text .= $message . "\n";

        # final answer
        my $peekaboo_answer = JSON::PP->new->utf8->decode($answer->decoded_content);

        # extend result text with report and reason from this result
        my $report = $peekaboo_answer->{"report"};
        if (defined($report)) {
          $result_text .= join("\n", @{$report});
        }

        $result_text .= $peekaboo_answer->{"reason"} . "\n";

        # check for bad or failure first
        my $result = $peekaboo_answer->{"result"};
        if ($result eq "failed") {
          # no sense in dragging this out since one failed analysis means we
          # cannot reach any conclusive verdict
          my $message = sprintf("Peekaboo: Job %d failed", $job);
          Amavis::Util::do_log(1, $message);
          return (undef, $result_text . $message . "\n", undef)
        } elsif ($result eq "bad") {
          # same applies for one bad sample: we found malware, done
          my $message = sprintf("Peekaboo: Job %d found malware", $job);
          Amavis::Util::do_log(5, $message);
          return (1, $result_text . $message . "\n", undef)
        }

        # everything else means that this job did not find malware nor fail
      } elsif ($code == 404) {
        # result not yet present
        Amavis::Util::do_log(5, "Peekaboo: Job %d not finished yet", $job);
        push(@jobs_left, $job);
        next;
      } else {
        # all other codes indicate some kind of error
        my $message = sprintf("Peekaboo: Received error %d when " .
                "requesting report for job %d", $code, $job);
        Amavis::Util::do_log(1, $message);
        return (undef, $result_text . $message . "\n", undef);
      }
    }

    @jobs = @jobs_left;
  }

  # see amavisd-new routines run_av() and virus_scan() for the meaning of these
  # return values.
  my $message = sprintf("Peekaboo: No malware found");
  Amavis::Util::do_log(1, $message);
  return (0, $result_text . $message . "\n", undef);
}

1;  # ensure a defined return value
